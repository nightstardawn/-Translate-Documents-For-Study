# C++ For C# Developers: Part 7 – Pointers, Arrays, and Strings

> 注：本文译自该[博客](https://www.jacksondunstan.com/articles/5583),仅供学习参考
> </br>在这个类似这种提示框内，皆为本人看法，如有错误欢迎指正

今天，我们将继续本系列 ，介绍指针，以及与 C# 截然不同的是，数组和字符串的相关概念。
</br>我们将介绍一些有趣的仅限 C++ 的功能，例如函数指针。

## Pointers  指针

只要我们将编译器配置为启用“不安全”代码，就允许使用 C# 指针。
然后，我们只需要在不安全的上下文中使用指针，例如函数中的 `unsafe` 方法、`unsafe` 类或 `unsafe` 块。

C++ 没有“安全”或“不安全”代码的概念。没有 “unsafe” 上下文、“safe” 上下文或启用 “unsafe” 代码的编译器选项。
</br>指针在任何地方都允许使用，并且通常在许多代码库中使用。事实证明，它们的语法与 C# 指针语法非常相似：

```c++
int x = 123;
 
// 声明一个指针类型：int* 是一个“指向整数的指针”
int* p = &x;
 
// 解引用指针以获取其值
DebugLog(*p); // 123
 
// 取消引用并分配指针以设置其值
*p = 456;
DebugLog(x); // 456
 
// x->y 是 (*x).y 的便捷简写
Player* p = &localPlayer;
p->Health = 100;
```

通过在类型中添加更多的 * 字符，也支持多级间接引用：

```c++
int x = 123;
int* p = &x;
int** pp = &p;
 
DebugLog(**pp); // 123
 
**pp = 456;
DebugLog(x); // 456
 
int y = 1000;
*pp = &y;
**pp = 2000;
DebugLog(x); // 456
DebugLog(y); // 2000
```

我们还有`void*`，它是指向任何类型的指针。由于编译器不知道应该对`void*`进行读取或写入操作的数据类型，因此需要类型转换来解引用void*。
</br>就像C#一样，这种转换在运行时不会被检查，以确保指针确实指向转换到的类型。

```c++
int x = 123;
 
// x是一个int*，但void*与所有指针类型兼容
void* pVoid = &x;
 
// 将类型转换回int*以便我们可以解引用
int* pInt = (int*)pVoid;
DebugLog(*pInt); // 123
 
// 将内存转换为float*，这样我们就可以将其视为持有另一种类型的数据
float* pFloat = (float*)pVoid;
*pFloat = 3.14f;
DebugLog(x); // 1078523331
```

最后一行可以被认为是整型的数据损坏，因为`3.14f`不是一个有效的整数值，但它是一种获取浮点数位的方法。这是这些类型转换不被检查的部分原因。

请注意，这被称为“类型欺骗”，在技术上属于未定义行为，这意味着编译器可能会为这种C++生成任意的机器代码。
</br>然而，至少在这个简单的情况下，所有编译器都会生成我们预期的机器代码，这样我们就可以将相同的内存当作不同类型来处理。

与在 C# 中一样，指针可能为 null。用 C++ 编写此命令有三种主要方式：

```c++
// nullptr与所有指针类型兼容，但不与整数算术兼容
//这通常是自C++11以来的首选方式
int* p1 = nullptr;
 
// NULL通常被定义为零，但可以与整数算术一起使用
int* p2 = NULL;
 
// 零整数
int* p3 = 0;
```

## Arrays  数组

将数组与指针归为同一篇文章似乎很奇怪，但它们在 C++ 中非常相似。与 C# 不同，数组不是“托管”的对象，并且受垃圾回收的约束。
</br>相反，它们只是相同类型数据的固定大小的连续分配：

```c++
// 声明一个包含3个整型元素的数组
// 该数组的元素尚未初始化
int a[3];
 
// 通过写入初始化数组的第一个元素
a[0] = 123;
 
// 读取数组中的第一个元素
DebugLog(a[0]); // 123
```

当我们创建一个数组变量时，就像我们通过变量单独创建它的元素一样：

```c++
int a0;
int a1;
int a2;
```

这意味着数组没有开销。它实际上只是它的元素。它甚至没有像 C# 中的 `Length` 字段那样跟踪其长度的整数。
</br>这意味着 C# `stackalloc` 关键字是不必要的，因为 C++ 数组在声明为局部变量时已在堆栈上分配。
</br>同样，用于创建固定大小缓冲区作为结构或类字段的 `fixed` 关键字是不必要的，因为 C++ 数组的元素已经存储在结构或类中。

数组中的索引也没有边界检查，就像在C#或C++中对指针进行索引一样。
</br>非常重要的是要注意不要读取数组的开始或结束之外的数据，因为通常无法知道将要读取或覆盖的数据是什么。

因为我们可以隐式地将数组转换为指针，所以界限变得更为模糊：

```c++
int a[3];
a[0] = 123;
 
// 隐式地将int[3]数组转换为int*，我们得到第一个元素的指针
int* p = a;
DebugLog(*p); // 123
 
// 指针索引的工作方式与C#中相同
DebugLog(p[0]); // 123
```

然而，相反的操作是不行的：我们不能写成`int b[3] = p`。

短数组通常使用大括号进行初始化：
```c++
int a[3] = { 123, 456, 789 };
DebugLog(a[0], a[1], a[2]); // 123, 456, 789
```

如果我们指定的元素数超过数组大小的大小，则会出现编译器错误：
```c++
int a[3] = { 123, 456, 789, 1000 }; // compiler error
```

如果我们指定的元素较少，则只会初始化我们指定的元素。请注意，允许使用尾部逗号：

```c++
int a[3] = { 123, 456, };
DebugLog(a[0], a[1]); // 123, 456
DebugLog(a[2]); // 未初始化。可能是任何东西！
```

使用大括号初始化数组时，通常会省略数组大小。这告诉编译器计算大括号中的元素数，并使数组变得那么长。
```c++
int a[] = { 123, 456, 789 }; // The a array has 3 elements
DebugLog(a[0], a[1], a[2]); // 123, 456, 789
```

最后，我们有多维数组。这些是数组的数组，都具有固定长度。这意味着它们从来都不是 “锯齿状” 的，而是总是 “矩形的”。
</br>就像一维数组一样，我们最终会得到相同类型数据的连续序列的连续序列。仍然没有开销：

```c++
int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
DebugLog(a[0][0], a[0][1], a[0][2]); // 1, 2, 3
DebugLog(a[1][0], a[1][1], a[1][2]); // 4, 5, 6
```

这些被隐式转换为指向数组第一维的指针：

```c++
int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
 
// 隐式转换为指向3个整数的数组的指针
// 将类型名称读作“p是一个指向3个int元素数组的指针”
int (*p)[3] = a;
 
// 取消该指针的引用以获取指向第一个元素的指针
int* pp = *p;
for (int i = 0; i < 6; ++i)
{
    DebugLog(pp[i]); // 1, 2, 3, 4, 5, 6
}
```

对下标少于其维度数的多维数组进行索引只会生成数组的剩余维度。我们可以使用相同的隐式转换在指针中捕获它：

```c++
int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
int* firstRow = a[0]; // 获取第二个维度作为指针的第二个维度
DebugLog(firstRow[0], firstRow[1], firstRow[2]); // 1, 2, 3
```

## Pointers to Arrays and Arrays of Pointers  指向数组的指针和指针数组

有时我们想要一个指向数组的指针。这本质上就是 C# 数组，因为我们只有对它的引用，而不是它的实际内容。以下是我们在 C++ 中如何做到这一点：

```c++
int a[] = { 1, 2, 3 };
 
// 添加一个*使其成为一个数组指针而不是仅仅是一个数组
int (*p)[3] = &a;
 
// 取消指针引用以获取数组，我们可以对其进行索引
DebugLog((*p)[0], (*p)[1], (*p)[2]); // 1, 2, 3
```

C# 不支持指向数组的指针，因为指针不能指向数组等托管类型。

如果我们想要一个指针数组，只需在 array 元素的类型中添加一个 `*`：

```c++
int x = 1;
int y = 2;
int z = 3;
 
// 在int前加一个*，可以得到int*：一个指向int的指针
int* a[] = { &x, &y, &z };
 
// 在数组中索引以获取指针，然后解引用以获取整数
DebugLog(*a[0], *a[1], *a[2]); // 1, 2, 3
```

C# 支持指针数组，但数组是我们只能引用的托管对象。

## Strings  字符串

字符串的区别类似于数组的区别。在 C# 中，我们管理了垃圾回收的 `System.String` 对象。在 C++ 中，我们基本上有以 `null` 结尾的字符数组：

```c++
// 字符串字面量 "hello" 的类型为 const char[6]，
// 它的内容是字符 'h', 'e', 'l', 'l', 'o', 0
const char hello[] = "hello";
 
// 就像任何其他数组一样，它隐式地转换为一个指针
const char* p = hello;
for (int i = 0; i < 6; ++i)
{
    DebugLog(p[i]); // h, e, l, l, o, <NUL>
}
```

我们稍后会详细介绍`const`(Part15)，但现阶段重要的是要知道数组中的字符不能被更改。例如，这将产生编译器错误：

在Part3，我们看到了存在各种字符字面量(Literals)。对于字符串来说也是如此，因为每个字符串都对应其数组中字符元素的类型：

| String Type 字符串类型 | Syntax 语法 | Meaning 意义              |
|-------------------|-----------|-------------------------|
| `char[]`          | “hello”   | ASCII string            |
| `wchar_t[]`       | L”hello”  | “Wide character” string |
| `char8_t[]`       | u8″hello” | UTF-8 string            |
| `char16_t[]`      | u”hello”  | UTF-16 string           |
| `char32_t[]`      | U”hello”  | UTF-32 string           |

无论字符类型如何，我们都可以通过将字符串文字放在一起来连接在一起。不需要 `+` 运算符，就像在 C# 中一样。

```c++
char msg[] = "Hello, " "world!";
DebugLog(msg); // Hello, world!
```

只要只有一个字符串字符字面量具有编码前缀，其他字符字面量也会获得它：

对混合编码前缀的支持因编译器而异。

原始字符串通常在需要字面量时使用，例如日志消息文本。
</br>当需要更高级的功能时，这非常常见，因此会使用包装类，例如C++标准库中的`string`或`Unreal的FString`来代替。
</br>我们将在本系列的后续部分介绍字符串。

## Pointer Arithmetic  指针运算

与 C# 一样，可以对指针执行算术运算：

```c++
int a[3] = { 0, 0, 0 };
 
int* p = a; // 让 p 指向 a 的第一个元素
*p = 1;
 
p += 2; // 让 p 指向 a 的第三个元素
*p = 3;
 
--p; // 让 p 指向 a 的第二个元素
*p = 2;
 
DebugLog(a[0], a[1], a[2]); // 1, 2, 3
```

还可以比较指针：

```c++
int a[3] = { 0, 0, 0 };
int* theStart = a;
int* theEnd = theStart + 3;
while (theStart < theEnd) // Compare pointers
{
    *theStart = 1;
    theStart++;
}
DebugLog(a[0], a[1], a[2]); // 1, 1, 1
```

回想一下`Part6` ，这满足基于范围的 for 循环的条件：

```c++
int a[3] = { 1, 2, 3 };
for (int val : a)
{
    DebugLog(val); // 1, 2, 3
}
```

编译器将其转换为正常的 `for` 循环：

```c++
{
    int*&& range = a;
    int* cur = range;
    int* theEnd = range + 3;
    for ( ; cur != theEnd; ++cur)
    {
        int val = *cur;
        DebugLog(val);
    }
}
```

请注意，在数组的特殊情况下不需要 `begin` 和 `end` 函数，因为编译器知道开始和结束指针，因为数组的大小在编译时是固定的。

## Function Pointers  函数指针

与 C# 不同，在 C++ 中，我们允许创建指向函数的指针：

```c++
int GetHealth(Player p)
{
    return p.Health;
}
 
// 获取GetHealth的指针。语法分为三个部分：
// 1) 返回类型：int
// 2) 指针名称：(*p)
// 3) 参数类型：(Player)
int (*p)(Player) = GetHealth;
 
// 调用函数指针会调用该函数
int health = p(localPlayer);
 
DebugLog(health);
```

这种语法的两种变体对功能没有影响：

```c++
// 将函数的地址分配，而不是仅仅分配其名称
int (*p)(Player) = &GetHealth;
 
// 在调用它之前解引用函数指针
int health = (*p)(localPlayer);
```

函数指针通常像 C# 中的委托一样使用。它们是一个可以传递的对象，当被调用时，它会调用一个函数。
不过，它们要轻得多，因为它们只是一个指针。委托具有更多功能，例如添加、删除和调用多个函数以及绑定到各种类型的函数（如实例方法和 `lambda`）的能力。
在本系列的后面部分，我们将介绍如何在 C++ 中执行此作。

要创建函数指针数组，请像以前一样在其名称后添加方括号 （`[]`）：

```c++
int GetHealth(Player p)
{
    return p.Health;
}
 
int GetLives(Player p)
{
    return p.Lives;
}
 
// 指向接收玩家并返回整数的函数的数组
int (*statFunctions[])(Player) = { GetHealth, GetLives };
 
// 像其他数组一样索引数组
int health = statFunctions[0](localPlayer);
DebugLog(health);
int lives = statFunctions[1](localPlayer);
DebugLog(lives);
```

函数指针数组通常用于[跳转表](https://en.wikipedia.org/wiki/Branch_table)，以用简单的数组索引读取操作替换长链条件逻辑。

## Conclusion  结论

C++ 指针功能包括 C# 指针可以执行的所有作，并增加了创建指向函数的指针和指向任何类型的指针的功能。
</br>数组和字符串与指针密切相关，这与托管的 C# 对应项不同。
</br>结合在一起，我们获得了许多增强的功能，例如用于创建跳转表的函数指针数组、委托的轻量级替代品，以及支持任何类型元素的 `stackalloc` 和固定大小缓冲区的替代方案。

























