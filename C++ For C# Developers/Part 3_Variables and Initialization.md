# C++ For C# Developers: Part 3 – Variables and Initialization

> 注：本文译自该[博客](https://www.jacksondunstan.com/articles/5543),仅供学习参考
> </br>在这个类似这种提示框内，皆为本人看法，如有错误欢迎指正

今天我们继续系列介绍变量及其初始化方法。这对C#开发者来说，又是另一个看似基础却充满复杂性的话题。

## Declaration  声明

C# 开发人员应该非常熟悉变量声明的基本形式：

```c++
int x;
```
就像在C#中一样，我们声明变量的类型、变量名，并以分号结尾。我们也可以在一行语句中声明多个变量：

```c++
int x, y, z;
```

也像C#一样，这些变量还没有赋值。考虑尝试读取这样的变量的值：

```c++
int x;
int y = x;
```

在C#中，这将在第二行导致编译器错误。编译器知道x没有值，因此不能读取并将其赋值给y。在
</br>C++中，这被称为“未定义行为”。当编译器遇到未定义行为时，它可以自由地为整个可执行文件生成任意代码。
</br>它可能产生也可能不产生警告或错误来警告这一点，这意味着它可能默默地生成一个作者认为不应该执行的程序。
</br>永远不要调用未定义行为非常重要，并且已经编写了工具来帮助避免这种情况。


这种未定义的行为确实有它的目的：速度。考虑这个例子：

```c++
int localPlayerHealth;
foreach (Player p in players)
{
    if (p.IsLocal)
    {
        localPlayerHealth = p.Health;
        break;
    }
}
Debug.Log(localPlayerHealth);
```

我们知道在我们的游戏设计中必须有一个本地玩家，因此在不进入循环之前不初始化`localPlayerHealth`是安全的。
</br>在这种情况下将其初始化为0将是浪费的，但C#编译器不了解我们的游戏设计，因此它无法证明我们总能找到本地玩家，并强迫我们进行初始化。

在C++中，我们可以自由地跳过这个初始化，并承担如果玩家数组中真的没有本地玩家时出现未定义行为的风险。或者，我们可以复制C#的方法，只是初始化变量以确保安全。

## Initialization  初始化

C++提供了许多初始化变量的方法。我们上面已经看到了一种，其中值被复制：

```c++
int x = y;
```

还有一些其他的方法，这些方法在C#中不存在：

```c++
int x{}; // x被填充了零，所以x等于0
int x{123};
int x(123);
```

存在许多其他类型的初始化，但这些特定于数组、类等某些类型。我们将在系列后续内容(Part13)中介绍这些内容。

所有这些初始化策略都可以在一条语句中声明多个变量时结合使用：

```c++
int a, b = 123, c{}, d{456}, e(789);
```

这将产生以下值：

| Variable | 	Value  价值 |
|----------|------------|
| a        | 	(Unknown) |
| b        | 	123       |
| c        | 	0         |
| d        | 	456       |
| e        | 	789       |

## Type Deduction  类型推导

在C#中，我们可以使用`var`来避免指定变量的类型。同样，C++有`auto`关键字：

```c++
auto x = 123;
auto x{123};
auto x(123);
```

与C#类似，我们只能在存在初始化器的情况下使用`auto`。

以下是不允许的：

```c++
auto x;
auto x{};
```

重要的是要记住 `x` 与显式指定 `int` 一样是强类型。这里发生的一切只是编译器在确定变量的类型，而不是我们手动输入。

一种较少见的方法是使用`decltype`运算符。这会解析为其参数的类型：

```c++
int x;
decltype(x) y = 123; // y is an int
```

最后，自C++17以来，`register`关键字已被弃用：

```c++
register int x = 123;
```

过去，它要求将变量放入CPU寄存器而不是RAM中，例如在栈上。编译器长期以来一直忽略了这个请求，所以现在最好避免使用这个关键字。

## Identifiers  标识符

C++标识符的命名规则与C#的规则相似。它们必须以字母、下划线或任何非数字Unicode字符开头。之后，它们可以包含任何Unicode字符，除了某些非常奇怪的字符。

此外，还有一些关于我们可以选择的名字的限制：


| Restriction                                                                         | 	Example   | 	Where                                                                                |
|-------------------------------------------------------------------------------------|------------|---------------------------------------------------------------------------------------|
| All keywords                                                                        | 	int for   | 	All code                                                                             |
| operator then an operator symbol</br>操作符然后是一个操作符符号                                  | 	operator+ | 	All code                                                                             |
| ~ then a class name</br>~然后是一个类名                                                    | 	~MyClass	 | All code                                                                              |
| Any name beginning with double underscores</br>任何以双下划线开头的名称                         | 	int __x   | 	All code except the Standard Library</br>除了标准库之外的所有代码                                |
| Any name beginning with an underscore then a capital letter</br>任何以下划线开头然后是首字母大写的名称 | 	int _X    | 	All code except the Standard Library</br>除了标准库之外的所有代码                                |
| Any name beginning with an underscore</br>任何以下划线开头的名称	                              | int _x	    | All code in the global namespace except the Standard Library</br>除了标准库之外的全局命名空间中的所有代码 |

没有等价于 C# 的“逐字标识符”（例如 `int @for`）来解决关键字限制。

## Pointers  指针

就像C#一样，至少当启用“不安全”功能时，C++有指针类型。语法甚至相似：

```c++
int* x;
int * x;
int *x;
```

`*`的位置是灵活的，就像在C#中一样。然而，在C++中，一行声明多个变量是不同的。考虑以下声明：

```c++
int* x, y, z;
```

`y`的类型在不同的语言中有所不同，因为在C++中，`*`运算符只附加到一个变量上：


| Language	 | Type of x | 	Type of y | 	Type of z |
|-----------|-----------|------------|------------|
| C#	       | int*	     | int*	      | int*       |
| C++       | 	int*     | 	int	      | int        |

要在 C++ 中将所有三个变量都转换为指针，请为每个变量添加 `*`：

或者省略 `*`，以便只有一些是指针：

```c++
int *x, *y, *z; // xyz都是指针
int *x, y, *z; // xz是指针，y是int
```

我们将在本系列后面更深入地介绍如何实际使用指针(Part8).

## References  引用

C++有两种引用类型：“左值引用”和“右值引用”。就像指针一样，这些是对其他类型的注释：

```c++
// 左值引用
int& x;
int & x;
int &x;
 
// 右值引用
int&& x;
int && x;
int &&x;
```

当每个语句声明多个变量时，与指针同样的规则在这里适用：`&` 或 `&&`只附加到一个变量上：

```c++
int &x, y; // x 是 int&, y 是 int
```

综上所述，这意味着我们可以为每个语句声明多个变量，并且每个变量都可以在所述类型上拥有自己的修饰符：

```c++
int a, *b, &c, &&d;
```

变量获得以下类型：

| Variable | 	Type |
|----------|-------|
| a	       | int   |
| b	       | int*  |
| c	       | int&  |
| d	       | int&& |

> 个人理解就是：在C++中与其说是为某个变量设定类型指针，不如说是为某个类型的变量设定为指针或者引用

在本系列的后面部分(Part8)，我们将深入探讨左值引用和右值引用的工作原理。
</br>现在，重要的是要知道它们就像不可为 `null` 的指针。这意味着我们必/br须在声明它们时初始化它们。
</br>以上所有行都将无法编译，因为我们没有编译。所以让我们纠正一下：/br

```c++
int x = 123;
int& y = x;
 
int&& z = 456;
```

这里我们有`y`作为一个“`int`的左值引用”。我们将其初始化为一个左值，这本质上是指任何有名称的东西。
</br>`x`有一个名称，并且类型正确：`int`。结果是，`y`现在引用了`x`。

`z`是一个“`int`的右值引用”。右值基本上是指没有名称的任何东西。
</br>我们将其初始化为`456`，它没有名称，但具有正确的类型：`int`。这意味着`z`现在引用了`456`。

把这些放在一起，我们最终会在需要时声明和初始化多个变量，如下所示：
```c++
int x = 123;
int a, *b, &c = x, &&d = 456;
```
## Conclusion  结论

概括地说，C++ 中的变量类似于 C#。不过，在细节上，存在非常重要的差异。
</br>由于未初始化它们而导致的 未定义行为、指针和引用字符仅适用于多个声明中的一个变量、各种新类型的初始化语法以及左值和右值引用的存在，即使在这种基本类型的变量中，也都构成了完全不同的情况。

在系列的后续部分，我们将讨论类、数组、函数指针、lambda表达式以及各种其他奇特主题，届时我们将扩展这个话题。请保持关注！