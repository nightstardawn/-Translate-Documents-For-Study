# C++ For C# Developers: Part 8 – References

> 注：本文译自该[博客](https://www.jacksondunstan.com/articles/5587),仅供学习参考
> </br>在这个类似这种提示框内，皆为本人看法，如有错误欢迎指正

本系列今天继续上一次的话题，从指针开始。
</br>我们将讨论C++中常用的一种替代方案：引用。这些与C#中的各种引用概念有很大不同！

正如我们上周所看到的，指针及其紧密关联的数组和字符串具有很大的灵活性。通常，它比我们真正想要的要灵活得多。在绝大多数情况下，我们只希望指针引用变量。
</br>我们不希望该变量为 null，我们不打算对指针执行算术运算，并且我们不想像数组一样对它进行索引。考虑像这样的函数声明：

```c++
int GetTotalPoints(Player*);
```

这让读者问自己一些问题，比如 “Player 指针可以为空吗？读者可能还会想“这是单个玩家还是他们的数组”以及“如果这是一个数组，它可以有多长？
</br>答案实际上取决于 `GetTotalPoints` 的实现，但我们不希望读者不得不猜测或花费时间跟踪和阅读函数定义。函数定义甚至可能不可用，例如对于闭源库。

## Lvalue References  左值引用

为了解决这些问题，C++ 引入了“引用”作为指针的替代方法。引用就像某个东西的别名，通常在编译的代码中以指针为后盾。这是看起来的：

```c++
int x = 123;
int& r = x; // <-- reference
DebugLog(x, r); // 123, 123
```

这有几个关键方面。首先，引用的语法类似于指针，只是我们在要引用的类型中添加 `&` 而不是 `*`
</br>在本例中为 `int`。我们可以将结果的 `int& r` 读作 “变量r是`int`的引用”

> 和指针一样，读者建议还是理解为：在C++中与其说是为某个变量设定类型指针，不如说是为某个类型的变量设定为指针或者引用

其次， 我们必须在声明引用时对其进行初始化。我们不能简单地编写 `int& r`;，否则我们会得到一个编译器错误。
</br>这有助于避免未定义行为，因为我们不可能读取或写入未定义引用。

第三，我们初始化引用的事物必须是有效的“左值”。这通常被认为是 “有名字的东西”。它包括变量和函数。
</br>这也意味着引用永远不能为 null，因为所有具有名称的内容在 C++ 中都有一个非 null 的内存地址。

第四，我们不像对指针那样初始化为 `&x`，也不用 `*x` 取消引用引用。
</br>我们简单地将其用作别名。
</br>任何提到 `r` 就像我们提到 `x` 一样。引用是别名，而不是对象。指针与它所指向的内容不同，可以独立操作，但引用不能。
</br>这意味着没有重新分配引用，因为我们实际上不能以这种方式引用引用：

```c++
int x = 123;
int y = 456;
int& r = x;
 
// 这等价于：
//   x = y;
// y 被读取和写入到 x
// r 仍然是 x 的别名
r = y;
 
DebugLog(x, r); // 456, 456
```

这通常更容易理解，因为与指针不同，引用在程序运行过程中永远不会改变其所指向的内容。
</br>然而，我们可以通过将第一个引用赋值给它来创建第二个引用：

```c++
int x = 123;
 
// Alias to x
int& r1 = x;
 
// 这相当于：
//   int& r2 = x;
//所以这也可以视为x的一个别名
int& r2 = r1;
 
DebugLog(r1, r2); // 123, 123
x = 456;
DebugLog(r1, r2); // 456, 456
```

由于引用不是不同的对象，因此没有对引用的引用、指向引用的指针或引用数组之类的东西：

以下是初始化引用的三种替代方法：

```c++
int& r(x);
int& r = {x};
int& r{x};
```
也可以使用上述两种形式将它们作为参数传递来初始化它们：

```c++
void AddOne(int& val)
{
    val += 1;
}
 
int x = 1;
 
AddOne(x);
DebugLog(x); // 2
 
AddOne({x});
DebugLog(x); // 3
```

同样，返回引用也会初始化它：

```c++
int nextId = 0;
 
int& GetNextId()
{
    nextId++;
    return nextId;
}
 
int& id = GetNextId();
DebugLog(id); // 1
id = 0; // Reset
DebugLog(nextId); // 0
```

现在让我们看看对函数的引用。这些看起来就像指向函数的指针，只是有一个`&`而不是一个`*`：

```c++
// 引用一个接受int类型参数并返回bool类型值的函数
bool (&r)(int) = MyFunc;
```
我们可以像这样使用它们：

```c++
// 根据某些匹配函数查找索引的函数
int FindIndex(int array[5], bool (&matcher)(int))
{
    for (int i = 0; i < 5; ++i)
    {
        if (matcher(array[i]))
        {
            return i;
        }
    }
    return -1;
}
 
bool IsEven(int val)
{
      return (val & 1) == 0;
}
 
// 引用我们的匹配函数
bool (&isEven)(int) = IsEven;
 
int array[5] = { 1, 2, 3, 4, 5 };
int index = FindIndex(array, isEven); // 传递引用，而不是函数
DebugLog(index);
```

因为我们可以通过传递参数来初始化引用，所以实际上没有必要显式地将`isEven`作为局部引用。相反，我们可以这样做：

```c++
// 传递函数的名称初始化匹配器引用参数
int index = FindIndex(array, IsEven);
```

当我们在编译时不知道要引用什么，并且想要反复使用运行时选择时，局部引用更有用：

```c++
// 在运行时决定要别名什么
bool (&matcher)(int) = userWantsEvens ? IsEven : IsOdd;
 
// 反复使用那个决定的成果
int index1 = FindIndex(array1, matcher);
int index2 = FindIndex(array2, matcher);
 
bool foundInBothArrays = index1 >= 0 && index2 >= 0;
```

以下是与指针相比，引用施加的限制的总结：
- 必须在声明时初始化
- 无法索引以偏移内存地址
- 不受指针算术的影响
- 没有引用的引用
- 没有指向引用的指针
- 没有引用数组
- 不能为 null
- 无法更改其别名

这似乎失去了很多灵活性，而且需要遵守的规则也更多，但结果证明，满足所有这些约束是非常常见的。
</br>除了最后三个之外，这些主要是C#引用强加给我们的约束，而且它们证明是非常实用的。
</br>实际上，C++引用被广泛用来简洁地向读者传达所有这些约束。
</br>让我们再看一下我们开始使用的函数，现在使用引用：

```c++
int GetTotalPoints(Player&);
```

现在很明显
</br>一、`Player` 不能为 `null`，因为引用不可能这样做。
</br>二、这不是 `Player` 对象的数组，因为这也是不可能的。
`&` 而不是 `*` 意味着它只是一个`非 null Player` 对象的别名。

## Rvalue References  右值引用

到目前为止，我们已经看到了引用如何为具有名称的“左值”创建别名。
</br>我们也可以为没有名称的事物创建引用。这些对“右值”的引用是在C++11中引入的，现在被广泛使用。

右值引用在其引用的类型后面有两个 &，并且使用没有名称的内容进行初始化：

```c++
int&& r = 5;
```

字面量`5`没有像变量那样的名字。
</br>然而，我们仍然可以引用它，并且它的生命周期被扩展到引用的生命周期，这样引用就永远不会指向不再存在的东西。
</br>它的工作方式是这样的：

```c++
{
    // 5是右值
    // 这不仅仅是一个临时变量在这一行
    int&& r = 5;
 
    // 123是右值，但它只是被写入到x中
    // 123在分号之后就不存在了
    int x = 123;
 
    // 引用值引用和变量仍然可读
    DebugLog(r, x); // 5, 123
 
    // r所引用的临时对象仍然可以通过别名访问
    r = 6;
    DebugLog(r, x); // 6, 123
 
    // 别担心，我们没有覆盖掉5的基本概念 :)”
    DebugLog(5); // 
 
// r所在的范围结束了
// r和5结束了它们的生命周期
// 它们不能再被使用了
}
```

与像int这样的原始数据类型相比，在结构和类中，生命周期扩展要重要得多，但规则是相同的。在系列的后续部分，我们将更深入地探讨结构和类。

相同的替代初始化形式也适用于右值引用：

```c++
int&& r(5);
int&& r = {5};
int&& r{5};
```

我们也可以使用函数参数进行初始化：

```c++
void PrintRange(int&& from, int&& to)
{
    for (int i = from; i <= to; ++i)
    {
        DebugLog(i);
    }
}
 
PrintRange(1, 3); // 1, 2, 3
```

返回值也可以初始化右值引用，但当我们返回一个临时对象时，这些引用将变成“悬垂”引用，因为它的生命周期不会延长到函数调用结束之后：

```c++
Player&& MakePlayer(int id, int health)
{
    // 创建一个临时Player
    // 将其别名设置为右值引用
    // 返回该别名
    return { id, health };
}
 
// 返回的右值引用是“悬垂的”
// 它指向一个已经不存在的临时Player
// 它不能被使用，否则会发生未定义的行为
Player&& player = MakePlayer(123, 100);
 
// 当我们从中读取时，我们会得到垃圾
DebugLog(player.Id, player.Health); // 17823804, 12850082
```

重要的是要记住这一点，并且只返回那些生命周期将延伸到函数调用结束之后的`rvalue`引用。我们将在本系列的后续部分看到一些实现这一点的技巧。

适用于左值引用的相同约束也适用于右值引用：

- 必须在声明时初始化 
- 不能用于索引以偏移内存地址 
- 不受指针算术的影响 
- 没有引用的引用 
- 没有指向引用的指针 
- 没有引用数组 
- 不能为空 
- 不能改变它所别名的内容 

此外，尽管命名相似，左值引用和右值引用是不同的类型。
</br>例如，考虑尝试使用左值调用上面的 PrintRange 函数：

```c++
int from = 1;
int to = 3;
 
// 编译器错误
// 当需要int&&时不能传递int&
PrintRange(from, to);
```

没有其他类型的rvalue引用初始化是可能的，即使是像这样简单的情况：

```c++
int x = 123;
 
// 编译器错误
// 当int&&需要右值时，x是一个左值
int&& r = x;
```

然而，当那个右值引用有一个名称时，我们可以将一个右值引用赋值给一个左值引用：

```c++
// 编译错误
// 当int&需要左值时，123是一个右值
int& error = 123;
 
int&& rr = 123;
int& lr = rr; // rr 有一个名字，所以它是一个左值
 
DebugLog(rr, lr); // 123, 123
rr = 456;
DebugLog(rr, lr); // 456, 456
```

当左值引用有名称时，情况相反不起作用，因为这样它就不再是右值：

```c++
int x = 123;
int& lr = x;
 
// 编译器错误
// 当int&&需要右值时，lr是一个左值
int&& rr = lr;
```

C#有几种引用类型。让我们将它们与C++的引用进行比较。

## C# References C#的引用

首先，有一个名为`ref`的关键字用于通过引用传递函数参数。这与C++的左值引用非常相似，因为参数必须是一个左值，并且像传递的变量的别名一样。
</br>尽管如此，也有一些区别。
</br>首先，C++在函数签名中使用`&`而不是`ref`，并且在调用函数时不需要`ref`关键字。
</br>其次，C#的`ref`参数只能是指向变量的引用，不能是函数。

在C#中，`out`和`in`参数修饰符也被描述为启用按引用传递功能。标记为`out`的参数类似于C++中的lvalue引用，但额外要求函数至少写入一次。
</br>在C++中，没有与之直接对应的功能，因为该语言倾向于避免在编译时要求执行写入操作，这与变量初始化的情况类似。
</br>另一方面，`in`参数基本上与C++中的`const lvalue`引用相同。
</br>我们将在稍后更深入地介绍`const`，但就目前而言，它可以被视为C#中`readonly`的增强版本。

其次，存在`ref`返回值和`ref`局部变量。这些与C++的lvalue引用类似，因为它们创建了一个对lvalue的别名。
</br>C++在`ref`返回值的函数签名和局部变量的声明中，都使用相同的`&`语法而不是`ref`。C#在return语句中也要求使用`ref`，但C++则不需要。

第三，C#中有`ref`和`readonly ref`结构体，通过强制实施各种限制来强制在堆栈上分配它们。这种“引用”的含义与C++中的左值引用或右值引用都没有关联。

第四点，最后，存在诸如类、接口、委托、动态对象、对象类型和字符串等引用类型。所有这些都是“托管”类型，受垃圾回收管理。
</br>由于C++没有“托管”类型或垃圾回收，因此也没有引用类型。相反，在C++中，可以引用任何类型。

尽管C++中的引用与C#中的引用的意义不同。
</br>在C#中，它们介于指针和C++引用之间。
</br>它们像指针一样，是一个对象，而不是别名。
</br>它们可以是null，并且可以被重新分配。
</br>它们像引用一样，不允许指针运算，并且不能像数组一样索引以偏移内存地址。

另一个主要区别是，当没有更多引用指向托管C#类型时，它们将受到垃圾回收的影响。这暗示了一种幕后跟踪机制，以确定是否还有可用的引用。
</br>这是一段非常复杂、有时成本高昂的代码，必须保证线程安全并处理一些晦涩的边缘情况。
</br>C++引用没有这样的跟踪，也不暗示任何宏大的资源管理方案。
</br>除了rvalue引用的生存期扩展，这通常相当短暂之外，没有尝试全局管理所有引用以实现任何目的，包括释放。

C++引用与C++指针、C#指针以及各种C#引用相似，但在许多方面又与它们不同。
</br>它的左值引用是一种独特的引用变量和函数的方式。它的右值引用尤其奇特，因为没有任何类似的概念提供接近相同的功能。
</br>随着系列的进行，我们将看到这两种引用在语言及其标准库的许多其他领域的日益重要性和常见用法。



















